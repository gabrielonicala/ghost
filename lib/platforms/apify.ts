/**
 * Apify Integration for Video Downloading and YouTube Processing
 * 
 * Supports:
 * - TikTok (clockworks/tiktok-scraper)
 * - Instagram (apify/instagram-scraper)
 * - Facebook (apify/facebook-posts-scraper)
 * - YouTube (multiple scrapers for complete processing):
 *   - Transcript + Metadata: Uwpce1RSXlrzF6WBA
 *   - Video Downloader: cmC0PdCbAkXY5NRAw
 *   - Comments: mExYO4A2k9976zMfA
 */

const APIFY_API_BASE = "https://api.apify.com/v2";

// YouTube Apify Actor IDs
const YOUTUBE_ACTORS = {
  transcript: "Uwpce1RSXlrzF6WBA",  // Transcript + views/likes/subscribers
  downloader: "cmC0PdCbAkXY5NRAw", // Direct video URL
  comments: "mExYO4A2k9976zMfA",   // Comments extraction
};

export interface ApifyVideoResult {
  videoUrl: string;
  thumbnailUrl?: string;
  caption?: string;
  author?: {
    id?: string;
    username: string;
    displayName?: string;
    profileUrl?: string;
    profileImageUrl?: string;
    followerCount?: number;
    verified?: boolean;
  };
  metrics?: {
    views?: number;
    likes?: number;
    comments?: number;
    shares?: number;
    saves?: number;
  };
  duration?: number;
  publishedAt?: Date;
}

// YouTube Transcript Scraper Response
export interface YouTubeTranscriptResult {
  videoId: string;
  channelId: string;
  channelName: string;
  subscriberCount: number;
  title: string;
  description: string;
  thumbnail: string;
  viewCount: number;
  likeCount: number;
  commentCount: number;
  durationSeconds: number;
  publishedAt: Date;
  transcript: Array<{
    start: number;
    end: number;
    text: string;
  }>;
  fullTranscriptText: string;
  language: string;
  isAutoGenerated: boolean;
  status: "success" | "error";
  message?: string;
}

// YouTube Video Downloader Response
export interface YouTubeDownloadResult {
  videoId: string;
  title: string;
  channelTitle: string;
  channelId: string;
  description: string;
  thumbnailUrl: string;
  viewCount: number;
  durationSeconds: number;
  directVideoUrl: string; // The key URL we need for OCR
  formats: Array<{
    itag: number;
    url: string;
    mimeType: string;
    quality: string;
    qualityLabel?: string;
    width?: number;
    height?: number;
  }>;
}

// YouTube Comments Response
export interface YouTubeComment {
  id: string;
  text: string;
  likeCount: string | number;
  replyCount: string | number;
  publishedTime: string;
  author: {
    id: string;
    name: string;
  };
}

export interface YouTubeCommentsResult {
  videoId: string;
  comments: YouTubeComment[];
  totalComments: number;
}

interface ApifyRunResult {
  id: string;
  status: string;
  defaultDatasetId: string;
}

/**
 * Check if Apify is configured
 */
export function isApifyConfigured(): boolean {
  const hasToken = !!process.env.APIFY_API_TOKEN;
  console.log(`[Apify] isApifyConfigured check: hasToken=${hasToken}, tokenLength=${process.env.APIFY_API_TOKEN?.length || 0}`);
  return hasToken;
}

/**
 * Get the appropriate Apify actor for a platform
 * Note: Actor IDs use ~ instead of / in API URLs
 */
function getActorId(platform: string): string {
  // Actor IDs for API calls use ~ instead of /
  const actors: Record<string, string> = {
    tiktok: "clockworks~tiktok-scraper",
    instagram: "apify~instagram-scraper",
    facebook: "apify~facebook-posts-scraper",
    youtube: "streamers~youtube-scraper",
  };

  const actorId = actors[platform];
  if (!actorId) {
    throw new Error(`No Apify actor configured for platform: ${platform}`);
  }

  return actorId;
}

/**
 * Run an Apify actor and wait for results
 */
async function runActor(
  actorId: string,
  input: Record<string, any>,
  timeoutMs: number = 120000 // 2 minutes
): Promise<any[]> {
  const apiToken = process.env.APIFY_API_TOKEN;
  if (!apiToken) {
    throw new Error("APIFY_API_TOKEN is not configured");
  }

  // Start the actor run
  const runResponse = await fetch(
    `${APIFY_API_BASE}/acts/${actorId}/runs?token=${apiToken}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(input),
    }
  );

  if (!runResponse.ok) {
    const error = await runResponse.text();
    throw new Error(`Failed to start Apify actor: ${error}`);
  }

  const runData: { data: ApifyRunResult } = await runResponse.json();
  const runId = runData.data.id;

  // Poll for completion
  const startTime = Date.now();
  while (Date.now() - startTime < timeoutMs) {
    const statusResponse = await fetch(
      `${APIFY_API_BASE}/actor-runs/${runId}?token=${apiToken}`
    );

    if (!statusResponse.ok) {
      throw new Error("Failed to check actor run status");
    }

    const statusData: { data: ApifyRunResult } = await statusResponse.json();

    if (statusData.data.status === "SUCCEEDED") {
      // Fetch results from dataset
      const datasetId = statusData.data.defaultDatasetId;
      const dataResponse = await fetch(
        `${APIFY_API_BASE}/datasets/${datasetId}/items?token=${apiToken}`
      );

      if (!dataResponse.ok) {
        throw new Error("Failed to fetch actor results");
      }

      return await dataResponse.json();
    }

    if (statusData.data.status === "FAILED" || statusData.data.status === "ABORTED") {
      throw new Error(`Apify actor run ${statusData.data.status}`);
    }

    // Wait before polling again
    await new Promise((resolve) => setTimeout(resolve, 2000));
  }

  throw new Error("Apify actor run timed out");
}

/**
 * Download TikTok video using Apify
 * Uses clockworks/tiktok-scraper actor
 */
export async function downloadTikTokVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  console.log("[Apify TikTok] Starting scrape for:", url);
  
  const results = await runActor("clockworks~tiktok-scraper", {
    postURLs: [url],
    commentsPerPost: 0,
    excludePinnedPosts: false,
    maxFollowersPerProfile: 0,
    maxFollowingPerProfile: 0,
    maxRepliesPerComment: 0,
    proxyCountryCode: "None",
    resultsPerPage: 1,
    scrapeRelatedVideos: false,
    shouldDownloadAvatars: false,
    shouldDownloadCovers: true, // Get thumbnail
    shouldDownloadMusicCovers: false,
    shouldDownloadSlideshowImages: false,
    shouldDownloadSubtitles: true, // Get subtitles if available
    shouldDownloadVideos: true, // Get direct video URL
  });

  console.log("[Apify TikTok] Got results:", JSON.stringify(results, null, 2).slice(0, 2000));

  if (!results || results.length === 0) {
    console.log("[Apify TikTok] No results returned");
    return null;
  }

  const video = results[0];
  console.log("[Apify TikTok] Video object keys:", Object.keys(video));

  // The video URL is in videoMeta.downloadAddr or mediaUrls[0]
  // These are direct MP4 URLs hosted on Apify's key-value store
  const videoUrl = 
    video.videoMeta?.downloadAddr ||  // Primary: direct download URL from Apify
    video.mediaUrls?.[0] ||            // Alternative: first media URL
    video.videoUrl ||                  // Fallback options
    video.downloadUrl;

  console.log("[Apify TikTok] Extracted videoUrl:", videoUrl);
  
  if (!videoUrl) {
    console.log("[Apify TikTok] Full video object:", JSON.stringify(video, null, 2));
  }

  return {
    videoUrl: videoUrl,
    thumbnailUrl: video.videoMeta?.coverUrl || video.videoMeta?.originalCoverUrl,
    caption: video.text,
    author: {
      id: video.authorMeta?.id,
      username: video.authorMeta?.name,
      displayName: video.authorMeta?.nickName,
      profileUrl: video.authorMeta?.profileUrl,
      profileImageUrl: video.authorMeta?.avatar,
      followerCount: video.authorMeta?.fans,
      verified: video.authorMeta?.verified || false,
    },
    metrics: {
      views: video.playCount,
      likes: video.diggCount,
      comments: video.commentCount,
      shares: video.shareCount,
      saves: video.collectCount,
    },
    duration: video.videoMeta?.duration,
    publishedAt: video.createTime ? new Date(video.createTime * 1000) : undefined,
  };
}

/**
 * Download Instagram video/reel using Apify
 */
export async function downloadInstagramVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  const results = await runActor("apify~instagram-scraper", {
    directUrls: [url],
    resultsType: "posts",
    resultsLimit: 1,
  });

  if (!results || results.length === 0) {
    return null;
  }

  const post = results[0];

  // Instagram can have multiple media items
  const videoUrl = post.videoUrl || post.displayUrl;

  if (!videoUrl) {
    return null;
  }

  return {
    videoUrl,
    thumbnailUrl: post.displayUrl,
    caption: post.caption,
    author: {
      username: post.ownerUsername,
      displayName: post.ownerFullName,
    },
    metrics: {
      views: post.videoViewCount,
      likes: post.likesCount,
      comments: post.commentsCount,
    },
    publishedAt: post.timestamp ? new Date(post.timestamp) : undefined,
  };
}

/**
 * Download Facebook video using Apify
 */
export async function downloadFacebookVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  const results = await runActor("apify~facebook-posts-scraper", {
    startUrls: [{ url }],
    resultsLimit: 1,
    includeVideoTranscript: true,
  });

  if (!results || results.length === 0) {
    return null;
  }

  const post = results[0];

  // Facebook video URL might be in different places
  const videoUrl = post.videoUrl || post.media?.[0]?.url;

  if (!videoUrl) {
    return null;
  }

  return {
    videoUrl,
    thumbnailUrl: post.media?.[0]?.thumbnail,
    caption: post.text,
    author: {
      username: post.pageName || post.userName,
      displayName: post.pageName || post.userName,
      profileUrl: post.pageUrl || post.userUrl,
    },
    metrics: {
      views: post.videoViewCount,
      likes: post.likes,
      comments: post.comments,
      shares: post.shares,
    },
    publishedAt: post.time ? new Date(post.time) : undefined,
  };
}

/**
 * Download YouTube video using Apify (for videos without captions)
 */
export async function downloadYouTubeVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  const results = await runActor("streamers~youtube-scraper", {
    startUrls: [{ url }],
    maxResults: 1,
    maxResultsShorts: 0,
    // Note: This actor provides metadata, not direct download URLs
    // You'll still need to use the video URL it provides
  });

  if (!results || results.length === 0) {
    return null;
  }

  const video = results[0];

  return {
    videoUrl: video.url || url,
    thumbnailUrl: video.thumbnailUrl,
    caption: `${video.title}\n\n${video.text || video.description || ""}`,
    author: {
      username: video.channelName || video.channelUrl?.split("/").pop(),
      displayName: video.channelName,
      profileUrl: video.channelUrl,
    },
    metrics: {
      views: video.viewCount,
      likes: video.likes,
      comments: video.commentsCount,
    },
    duration: video.duration,
    publishedAt: video.date ? new Date(video.date) : undefined,
  };
}

/**
 * Download video from any supported platform using Apify
 */
export async function downloadVideoWithApify(
  url: string,
  platform: "tiktok" | "instagram" | "facebook" | "youtube"
): Promise<ApifyVideoResult | null> {
  if (!isApifyConfigured()) {
    throw new Error(
      "Apify is not configured. Please add APIFY_API_TOKEN to your environment variables."
    );
  }

  switch (platform) {
    case "tiktok":
      return downloadTikTokVideo(url);
    case "instagram":
      return downloadInstagramVideo(url);
    case "facebook":
      return downloadFacebookVideo(url);
    case "youtube":
      return downloadYouTubeVideo(url);
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }
}

/**
 * Download the actual video file from the URL returned by Apify
 */
export async function downloadVideoFile(videoUrl: string): Promise<Buffer> {
  console.log("[Apify] Downloading video from URL:", videoUrl);
  
  const response = await fetch(videoUrl, {
    headers: {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      "Referer": "https://www.tiktok.com/",
      "Accept": "*/*",
    },
    redirect: "follow",
  });

  if (!response.ok) {
    throw new Error(`Failed to download video: ${response.status} ${response.statusText}`);
  }

  const contentType = response.headers.get("content-type") || "";
  console.log("[Apify] Download response content-type:", contentType);
  
  // Check if we got HTML instead of video (error page)
  if (contentType.includes("text/html")) {
    const text = await response.text();
    console.log("[Apify] Got HTML instead of video:", text.slice(0, 500));
    throw new Error("Downloaded content is HTML, not a video file. The video URL may have expired or be invalid.");
  }

  const arrayBuffer = await response.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  
  console.log("[Apify] Downloaded", buffer.length, "bytes. First 20 bytes:", buffer.slice(0, 20).toString("hex"));
  
  // Validate it looks like a video file
  if (buffer.length < 1000) {
    throw new Error(`Downloaded file is too small (${buffer.length} bytes). Video URL may be invalid.`);
  }
  
  return buffer;
}

// ============================================================================
// YOUTUBE APIFY SCRAPERS
// ============================================================================

/**
 * Fetch YouTube transcript + metadata using Apify
 * Actor: Uwpce1RSXlrzF6WBA
 * 
 * Input format:
 * {
 *   "include_transcript_text": false,
 *   "youtube_url": "https://www.youtube.com/watch?v=VIDEO_ID"
 * }
 * 
 * Returns: transcript (with timestamps), channel info, views, likes, subscribers
 */
export async function fetchYouTubeTranscript(
  videoUrl: string
): Promise<YouTubeTranscriptResult | null> {
  console.log("[Apify YouTube Transcript] Starting scrape for:", videoUrl);
  
  // Correct input format for this actor
  const results = await runActor(YOUTUBE_ACTORS.transcript, {
    youtube_url: videoUrl,
    include_transcript_text: true, // We want the transcript!
  });

  console.log("[Apify YouTube Transcript] Raw results:", JSON.stringify(results, null, 2).slice(0, 2000));

  if (!results || results.length === 0) {
    console.log("[Apify YouTube Transcript] No results returned");
    return null;
  }

  const video = results[0];
  
  // Check if scrape was successful
  if (video.status !== "success") {
    console.error("[Apify YouTube Transcript] Scrape failed:", video.message);
    return null;
  }

  // Build the full transcript text from segments
  const transcriptSegments = video.transcript || [];
  const fullTranscriptText = transcriptSegments
    .map((seg: { text: string }) => seg.text)
    .join(" ")
    .trim();

  console.log("[Apify YouTube Transcript] Extracted transcript length:", fullTranscriptText.length);
  console.log("[Apify YouTube Transcript] Transcript preview:", fullTranscriptText.slice(0, 500));

  return {
    videoId: video.video_id || video.videoId,
    channelId: video.channel_id || video.channelId,
    channelName: video.channel_name || video.channelName,
    subscriberCount: video.subscriber_count || video.subscriberCount || 0,
    title: video.title,
    description: video.description || "",
    thumbnail: video.thumbnail,
    viewCount: video.view_count || video.viewCount || 0,
    likeCount: video.like_count || video.likeCount || 0,
    commentCount: video.comment_count || video.commentCount || 0,
    durationSeconds: video.duration_seconds || video.durationSeconds || 0,
    publishedAt: video.published_at ? new Date(video.published_at) : new Date(),
    transcript: transcriptSegments.map((seg: { start: number; end: number; text: string }) => ({
      start: seg.start,
      end: seg.end,
      text: seg.text,
    })),
    fullTranscriptText,
    language: video.language || video.selected_language || "en",
    isAutoGenerated: video.is_auto_generated || video.isAutoGenerated || false,
    status: "success",
    message: video.message,
  };
}

/**
 * Get direct YouTube video download URL using Apify
 * Actor: cmC0PdCbAkXY5NRAw
 * 
 * Input format:
 * {
 *   "urls": [{ "url": "https://www.youtube.com/watch?v=VIDEO_ID" }]
 * }
 * 
 * NOTE: The returned video URLs are IP-restricted (signed for Apify's IP).
 * Downloading from a different IP (like Vercel) will result in 403 Forbidden.
 * 
 * Returns: Direct video URL that can be used for OCR/Video Intelligence API
 */
export async function fetchYouTubeDirectVideoUrl(
  videoUrl: string
): Promise<YouTubeDownloadResult | null> {
  console.log("[Apify YouTube Downloader] Starting scrape for:", videoUrl);
  
  // Correct input format for this actor
  const results = await runActor(YOUTUBE_ACTORS.downloader, {
    urls: [{ url: videoUrl }],
  });

  console.log("[Apify YouTube Downloader] Raw results:", JSON.stringify(results, null, 2).slice(0, 3000));

  if (!results || results.length === 0) {
    console.log("[Apify YouTube Downloader] No results returned");
    return null;
  }

  const result = results[0];
  
  // Check status
  if (result.status !== "ok") {
    console.error("[Apify YouTube Downloader] Scrape failed:", result.status);
    return null;
  }

  const videoInfo = result.videoInfo;
  if (!videoInfo) {
    console.error("[Apify YouTube Downloader] No videoInfo in result");
    return null;
  }

  // Extract formats - prefer MP4, highest quality
  const allFormats = [
    ...(videoInfo.formats || []),
    ...(videoInfo.adaptiveFormats || []),
  ];

  // Filter for video formats (not audio-only)
  const videoFormats = allFormats.filter(
    (f: any) => f.mimeType?.includes("video/") && f.url
  );

  // Sort by quality (prefer 720p MP4)
  const sortedFormats = videoFormats.sort((a: any, b: any) => {
    // Prefer MP4 over WebM
    const aIsMp4 = a.mimeType?.includes("video/mp4") ? 1 : 0;
    const bIsMp4 = b.mimeType?.includes("video/mp4") ? 1 : 0;
    if (aIsMp4 !== bIsMp4) return bIsMp4 - aIsMp4;
    
    // Prefer 720p (not too high, not too low)
    const aHeight = a.height || 0;
    const bHeight = b.height || 0;
    const aDiff = Math.abs(aHeight - 720);
    const bDiff = Math.abs(bHeight - 720);
    return aDiff - bDiff;
  });

  // Get the best format URL
  const bestFormat = sortedFormats[0];
  const directVideoUrl = bestFormat?.url || videoFormats[0]?.url;

  if (!directVideoUrl) {
    console.error("[Apify YouTube Downloader] No video URL found in formats");
    console.log("[Apify YouTube Downloader] Available formats:", 
      allFormats.map((f: any) => ({ itag: f.itag, mimeType: f.mimeType, quality: f.quality }))
    );
    return null;
  }

  console.log("[Apify YouTube Downloader] Found direct URL:", directVideoUrl.slice(0, 100) + "...");
  console.log("[Apify YouTube Downloader] Best format:", {
    itag: bestFormat?.itag,
    quality: bestFormat?.qualityLabel || bestFormat?.quality,
    mimeType: bestFormat?.mimeType,
  });

  // Get best thumbnail
  const thumbnails = videoInfo.thumbnail || [];
  const bestThumbnail = thumbnails.find((t: any) => t.width >= 480) || thumbnails[0];

  return {
    videoId: videoInfo.id,
    title: videoInfo.title,
    channelTitle: videoInfo.channelTitle,
    channelId: videoInfo.channelId,
    description: videoInfo.description || "",
    thumbnailUrl: bestThumbnail?.url || "",
    viewCount: parseInt(videoInfo.viewCount || "0", 10),
    durationSeconds: parseInt(videoInfo.lengthSeconds || "0", 10),
    directVideoUrl,
    formats: videoFormats.map((f: any) => ({
      itag: f.itag,
      url: f.url,
      mimeType: f.mimeType,
      quality: f.quality,
      qualityLabel: f.qualityLabel,
      width: f.width,
      height: f.height,
    })),
  };
}

/**
 * Fetch YouTube comments using Apify
 * Actor: mExYO4A2k9976zMfA
 * 
 * Input format:
 * {
 *   "customMapFunction": "(object) => { return {...object} }",
 *   "maxItems": 1000,
 *   "sort": "top",
 *   "startUrls": ["https://www.youtube.com/watch?v=VIDEO_ID"]
 * }
 * 
 * Returns: Array of comments with author info, text, likes, replies
 */
export async function fetchYouTubeComments(
  videoUrl: string,
  maxComments: number = 100
): Promise<YouTubeCommentsResult | null> {
  console.log("[Apify YouTube Comments] Starting scrape for:", videoUrl);
  
  // Correct input format for this actor - startUrls is array of strings
  const results = await runActor(YOUTUBE_ACTORS.comments, {
    startUrls: [videoUrl], // Array of URL strings, not objects
    maxItems: maxComments,
    sort: "top",
    customMapFunction: "(object) => { return {...object} }",
  }, 180000); // 3 minute timeout for comments

  console.log("[Apify YouTube Comments] Raw results count:", results?.length || 0);
  console.log("[Apify YouTube Comments] First result:", JSON.stringify(results?.[0], null, 2)?.slice(0, 500));

  if (!results || results.length === 0) {
    console.log("[Apify YouTube Comments] No results returned");
    return null;
  }

  // Extract video ID from URL
  const videoIdMatch = videoUrl.match(/(?:youtube\.com\/(?:watch\?v=|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
  const videoId = videoIdMatch?.[1] || "";

  // Parse comments from results
  const comments: YouTubeComment[] = results.map((comment: any) => ({
    id: comment.id,
    text: comment.text,
    likeCount: parseCommentCount(comment.likeCount),
    replyCount: parseCommentCount(comment.replyCount),
    publishedTime: comment.publishedTime,
    author: {
      id: comment["author.id"] || comment.authorId || "",
      name: comment["author.name"] || comment.authorName || "",
    },
  }));

  console.log("[Apify YouTube Comments] Parsed", comments.length, "comments");

  return {
    videoId,
    comments,
    totalComments: comments.length,
  };
}

/**
 * Parse comment count strings like "4K", "5.9K", "2.9K" to numbers
 */
function parseCommentCount(count: string | number | undefined): number {
  if (typeof count === "number") return count;
  if (!count) return 0;
  
  const str = String(count).toLowerCase().trim();
  
  if (str.endsWith("k")) {
    return Math.round(parseFloat(str.replace("k", "")) * 1000);
  }
  if (str.endsWith("m")) {
    return Math.round(parseFloat(str.replace("m", "")) * 1000000);
  }
  
  return parseInt(str, 10) || 0;
}

/**
 * Comprehensive YouTube processing using all three Apify scrapers
 * 
 * Returns combined data from all three scrapers for complete YouTube content processing
 */
export async function processYouTubeWithApify(
  videoUrl: string,
  options: {
    fetchTranscript?: boolean;
    fetchDirectVideoUrl?: boolean;
    fetchComments?: boolean;
    maxComments?: number;
  } = {}
): Promise<{
  transcript?: YouTubeTranscriptResult | null;
  download?: YouTubeDownloadResult | null;
  comments?: YouTubeCommentsResult | null;
}> {
  const {
    fetchTranscript = true,
    fetchDirectVideoUrl = true,
    fetchComments = false,
    maxComments = 100,
  } = options;

  console.log("[Apify YouTube] Processing YouTube content with options:", options);

  // Run scrapers in parallel for efficiency
  const promises: Promise<any>[] = [];
  const results: {
    transcript?: YouTubeTranscriptResult | null;
    download?: YouTubeDownloadResult | null;
    comments?: YouTubeCommentsResult | null;
  } = {};

  if (fetchTranscript) {
    promises.push(
      fetchYouTubeTranscript(videoUrl)
        .then((r) => { results.transcript = r; })
        .catch((e) => { 
          console.error("[Apify YouTube] Transcript scraper failed:", e.message);
          results.transcript = null;
        })
    );
  }

  if (fetchDirectVideoUrl) {
    promises.push(
      fetchYouTubeDirectVideoUrl(videoUrl)
        .then((r) => { results.download = r; })
        .catch((e) => { 
          console.error("[Apify YouTube] Downloader scraper failed:", e.message);
          results.download = null;
        })
    );
  }

  if (fetchComments) {
    promises.push(
      fetchYouTubeComments(videoUrl, maxComments)
        .then((r) => { results.comments = r; })
        .catch((e) => { 
          console.error("[Apify YouTube] Comments scraper failed:", e.message);
          results.comments = null;
        })
    );
  }

  await Promise.all(promises);

  console.log("[Apify YouTube] Processing complete:", {
    hasTranscript: !!results.transcript?.fullTranscriptText,
    hasDirectUrl: !!results.download?.directVideoUrl,
    commentCount: results.comments?.totalComments || 0,
  });

  return results;
}

