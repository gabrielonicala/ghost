/**
 * Apify Integration for Video Downloading and YouTube Processing
 * 
 * Supports:
 * - TikTok (clockworks/tiktok-scraper)
 * - Instagram (apify/instagram-scraper)
 * - Facebook (apify/facebook-posts-scraper)
 * - YouTube (multiple scrapers for complete processing):
 *   - Transcript + Metadata: Uwpce1RSXlrzF6WBA
 *   - Video Downloader: y1IMcEPawMQPafm02 (stores on Apify key-value store)
 *   - Comments: mExYO4A2k9976zMfA
 * - Multi-platform Transcript: JfsnkyrbdA9JkpkRJ (TikTok, Instagram, Facebook, X)
 */

const APIFY_API_BASE = "https://api.apify.com/v2";

// YouTube Apify Actor IDs
const YOUTUBE_ACTORS = {
  transcript: "Uwpce1RSXlrzF6WBA",  // Transcript + views/likes/subscribers
  downloader: "y1IMcEPawMQPafm02", // Video downloader (stores on Apify key-value store)
  comments: "mExYO4A2k9976zMfA",   // Comments extraction
};

// Multi-platform Video Transcript Actor (TikTok, Instagram, Facebook, X)
const VIDEO_TRANSCRIPT_ACTOR = "JfsnkyrbdA9JkpkRJ";

export interface ApifyVideoResult {
  videoUrl: string;
  thumbnailUrl?: string;
  caption?: string;
  author?: {
    id?: string;
    username: string;
    displayName?: string;
    profileUrl?: string;
    profileImageUrl?: string;
    followerCount?: number;
    verified?: boolean;
  };
  metrics?: {
    views?: number;
    likes?: number;
    comments?: number;
    shares?: number;
    saves?: number;
  };
  duration?: number;
  publishedAt?: Date;
}

// Multi-platform Video Transcript Response (TikTok, Instagram, Facebook, X)
export interface VideoTranscriptResult {
  video_url: string;
  title: string;
  description: string;
  thumbnail: string;
  duration: number;
  transcript: Array<{
    text: string;
    start: number;
    end: number;
  }>;
  fullTranscriptText: string; // We'll build this from segments
}

// YouTube Transcript Scraper Response
export interface YouTubeTranscriptResult {
  videoId: string;
  channelId: string;
  channelName: string;
  subscriberCount: number;
  title: string;
  description: string;
  thumbnail: string;
  viewCount: number;
  likeCount: number;
  commentCount: number;
  durationSeconds: number;
  publishedAt: Date;
  transcript: Array<{
    start: number;
    end: number;
    text: string;
  }>;
  fullTranscriptText: string;
  language: string;
  isAutoGenerated: boolean;
  status: "success" | "error";
  message?: string;
}

// YouTube Video Downloader Response
export interface YouTubeDownloadResult {
  videoId: string;
  title: string;
  channelTitle: string;
  channelId: string;
  description: string;
  thumbnailUrl: string;
  viewCount: number;
  durationSeconds: number;
  directVideoUrl: string; // The key URL we need for OCR
  formats: Array<{
    itag: number;
    url: string;
    mimeType: string;
    quality: string;
    qualityLabel?: string;
    width?: number;
    height?: number;
  }>;
}

// YouTube Comments Response
export interface YouTubeComment {
  id: string;
  text: string;
  likeCount: string | number;
  replyCount: string | number;
  publishedTime: string;
  author: {
    id: string;
    name: string;
  };
}

export interface YouTubeCommentsResult {
  videoId: string;
  comments: YouTubeComment[];
  totalComments: number;
}

interface ApifyRunResult {
  id: string;
  status: string;
  defaultDatasetId: string;
  defaultKeyValueStoreId?: string;
}

/**
 * Check if Apify is configured
 */
export function isApifyConfigured(): boolean {
  const hasToken = !!process.env.APIFY_API_TOKEN;
  console.log(`[Apify] isApifyConfigured check: hasToken=${hasToken}, tokenLength=${process.env.APIFY_API_TOKEN?.length || 0}`);
  return hasToken;
}

/**
 * Get the appropriate Apify actor for a platform
 * Note: Actor IDs use ~ instead of / in API URLs
 */
function getActorId(platform: string): string {
  // Actor IDs for API calls use ~ instead of /
  const actors: Record<string, string> = {
    tiktok: "clockworks~tiktok-scraper",
    instagram: "apify~instagram-scraper",
    facebook: "apify~facebook-posts-scraper",
    youtube: "streamers~youtube-scraper",
  };

  const actorId = actors[platform];
  if (!actorId) {
    throw new Error(`No Apify actor configured for platform: ${platform}`);
  }

  return actorId;
}

/**
 * Run an Apify actor and wait for results
 */
async function runActor(
  actorId: string,
  input: Record<string, any>,
  timeoutMs: number = 120000 // 2 minutes
): Promise<any[]> {
  const apiToken = process.env.APIFY_API_TOKEN;
  if (!apiToken) {
    throw new Error("APIFY_API_TOKEN is not configured");
  }

  // Start the actor run
  const runResponse = await fetch(
    `${APIFY_API_BASE}/acts/${actorId}/runs?token=${apiToken}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(input),
    }
  );

  if (!runResponse.ok) {
    const error = await runResponse.text();
    throw new Error(`Failed to start Apify actor: ${error}`);
  }

  const runData: { data: ApifyRunResult } = await runResponse.json();
  const runId = runData.data.id;
  console.log(`[Apify] Actor started, run ID: ${runId}`);

  // Poll for completion
  const startTime = Date.now();
  let pollCount = 0;
  while (Date.now() - startTime < timeoutMs) {
    pollCount++;
    const statusResponse = await fetch(
      `${APIFY_API_BASE}/actor-runs/${runId}?token=${apiToken}`
    );

    if (!statusResponse.ok) {
      const errorText = await statusResponse.text();
      console.error(`[Apify] Status check failed: ${statusResponse.status} - ${errorText}`);
      throw new Error("Failed to check actor run status");
    }

    const statusData: { data: ApifyRunResult } = await statusResponse.json();
    const status = statusData.data.status;
    
    // Log status every 5 polls or on status change
    if (pollCount % 5 === 1 || status !== "RUNNING") {
      console.log(`[Apify] Poll #${pollCount}: status=${status}, elapsed=${Math.round((Date.now() - startTime) / 1000)}s`);
    }

    if (status === "SUCCEEDED") {
      console.log(`[Apify] Actor completed successfully after ${Math.round((Date.now() - startTime) / 1000)}s`);
      
      // Try fetching results from dataset first
      const datasetId = statusData.data.defaultDatasetId;
      console.log(`[Apify] Fetching results from dataset: ${datasetId}`);
      const dataResponse = await fetch(
        `${APIFY_API_BASE}/datasets/${datasetId}/items?token=${apiToken}`
      );

      if (dataResponse.ok) {
        const results = await dataResponse.json();
        console.log(`[Apify] Got ${results.length} results from dataset`);
        
        if (results.length > 0) {
          return results;
        }
      }
      
      // If dataset is empty, try key-value store (some actors store results there)
      const kvStoreId = statusData.data.defaultKeyValueStoreId;
      if (kvStoreId) {
        console.log(`[Apify] Dataset empty, checking key-value store: ${kvStoreId}`);
        
        // List keys in the key-value store
        const kvListResponse = await fetch(
          `${APIFY_API_BASE}/key-value-stores/${kvStoreId}/keys?token=${apiToken}`
        );
        
        if (kvListResponse.ok) {
          const kvList = await kvListResponse.json();
          console.log(`[Apify] Key-value store has ${kvList.data?.items?.length || 0} items`);
          
          // Look for OUTPUT or result keys
          const outputKey = kvList.data?.items?.find((item: any) => 
            item.key === "OUTPUT" || item.key.endsWith(".json") || item.key === "results"
          );
          
          if (outputKey) {
            console.log(`[Apify] Found output key: ${outputKey.key}`);
            const kvDataResponse = await fetch(
              `${APIFY_API_BASE}/key-value-stores/${kvStoreId}/records/${outputKey.key}?token=${apiToken}`
            );
            
            if (kvDataResponse.ok) {
              const kvData = await kvDataResponse.json();
              console.log(`[Apify] Got data from key-value store`);
              return Array.isArray(kvData) ? kvData : [kvData];
            }
          }
          
          // Log all keys for debugging
          console.log(`[Apify] All KV store keys:`, kvList.data?.items?.map((i: any) => i.key));
        }
      }
      
      console.warn(`[Apify] Actor succeeded but no results found in dataset or key-value store`);
      return [];
    }

    if (status === "FAILED" || status === "ABORTED") {
      console.error(`[Apify] Actor run ${status}`);
      throw new Error(`Apify actor run ${status}`);
    }

    // Wait before polling again
    await new Promise((resolve) => setTimeout(resolve, 2000));
  }

  console.error(`[Apify] Timeout after ${pollCount} polls, ${Math.round((Date.now() - startTime) / 1000)}s`);
  throw new Error("Apify actor run timed out");
}

/**
 * Download TikTok video using Apify
 * Uses clockworks/tiktok-scraper actor
 */
export async function downloadTikTokVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  console.log("[Apify TikTok] Starting scrape for:", url);
  
  const results = await runActor("clockworks~tiktok-scraper", {
    postURLs: [url],
    commentsPerPost: 0,
    excludePinnedPosts: false,
    maxFollowersPerProfile: 0,
    maxFollowingPerProfile: 0,
    maxRepliesPerComment: 0,
    proxyCountryCode: "None",
    resultsPerPage: 1,
    scrapeRelatedVideos: false,
    shouldDownloadAvatars: false,
    shouldDownloadCovers: true, // Get thumbnail
    shouldDownloadMusicCovers: false,
    shouldDownloadSlideshowImages: false,
    shouldDownloadSubtitles: true, // Get subtitles if available
    shouldDownloadVideos: true, // Get direct video URL
  });

  console.log("[Apify TikTok] Got results:", JSON.stringify(results, null, 2).slice(0, 2000));

  if (!results || results.length === 0) {
    console.log("[Apify TikTok] No results returned");
    return null;
  }

  const video = results[0];
  console.log("[Apify TikTok] Video object keys:", Object.keys(video));

  // The video URL is in videoMeta.downloadAddr or mediaUrls[0]
  // These are direct MP4 URLs hosted on Apify's key-value store
  const videoUrl = 
    video.videoMeta?.downloadAddr ||  // Primary: direct download URL from Apify
    video.mediaUrls?.[0] ||            // Alternative: first media URL
    video.videoUrl ||                  // Fallback options
    video.downloadUrl;

  console.log("[Apify TikTok] Extracted videoUrl:", videoUrl);
  
  if (!videoUrl) {
    console.log("[Apify TikTok] Full video object:", JSON.stringify(video, null, 2));
  }

  return {
    videoUrl: videoUrl,
    thumbnailUrl: video.videoMeta?.coverUrl || video.videoMeta?.originalCoverUrl,
    caption: video.text,
    author: {
      id: video.authorMeta?.id,
      username: video.authorMeta?.name,
      displayName: video.authorMeta?.nickName,
      profileUrl: video.authorMeta?.profileUrl,
      profileImageUrl: video.authorMeta?.avatar,
      followerCount: video.authorMeta?.fans,
      verified: video.authorMeta?.verified || false,
    },
    metrics: {
      views: video.playCount,
      likes: video.diggCount,
      comments: video.commentCount,
      shares: video.shareCount,
      saves: video.collectCount,
    },
    duration: video.videoMeta?.duration,
    publishedAt: video.createTime ? new Date(video.createTime * 1000) : undefined,
  };
}

/**
 * Download Instagram video/reel using Apify
 */
export async function downloadInstagramVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  const results = await runActor("apify~instagram-scraper", {
    directUrls: [url],
    resultsType: "posts",
    resultsLimit: 1,
  });

  if (!results || results.length === 0) {
    return null;
  }

  const post = results[0];

  // Instagram can have multiple media items
  const videoUrl = post.videoUrl || post.displayUrl;

  if (!videoUrl) {
    return null;
  }

  return {
    videoUrl,
    thumbnailUrl: post.displayUrl,
    caption: post.caption,
    author: {
      username: post.ownerUsername,
      displayName: post.ownerFullName,
    },
    metrics: {
      views: post.videoViewCount,
      likes: post.likesCount,
      comments: post.commentsCount,
    },
    publishedAt: post.timestamp ? new Date(post.timestamp) : undefined,
  };
}

/**
 * Download Facebook video using Apify
 */
export async function downloadFacebookVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  const results = await runActor("apify~facebook-posts-scraper", {
    startUrls: [{ url }],
    resultsLimit: 1,
    includeVideoTranscript: true,
  });

  if (!results || results.length === 0) {
    return null;
  }

  const post = results[0];

  // Facebook video URL might be in different places
  const videoUrl = post.videoUrl || post.media?.[0]?.url;

  if (!videoUrl) {
    return null;
  }

  return {
    videoUrl,
    thumbnailUrl: post.media?.[0]?.thumbnail,
    caption: post.text,
    author: {
      username: post.pageName || post.userName,
      displayName: post.pageName || post.userName,
      profileUrl: post.pageUrl || post.userUrl,
    },
    metrics: {
      views: post.videoViewCount,
      likes: post.likes,
      comments: post.comments,
      shares: post.shares,
    },
    publishedAt: post.time ? new Date(post.time) : undefined,
  };
}

/**
 * Download YouTube video using Apify (for videos without captions)
 */
export async function downloadYouTubeVideo(
  url: string
): Promise<ApifyVideoResult | null> {
  const results = await runActor("streamers~youtube-scraper", {
    startUrls: [{ url }],
    maxResults: 1,
    maxResultsShorts: 0,
    // Note: This actor provides metadata, not direct download URLs
    // You'll still need to use the video URL it provides
  });

  if (!results || results.length === 0) {
    return null;
  }

  const video = results[0];

  return {
    videoUrl: video.url || url,
    thumbnailUrl: video.thumbnailUrl,
    caption: `${video.title}\n\n${video.text || video.description || ""}`,
    author: {
      username: video.channelName || video.channelUrl?.split("/").pop(),
      displayName: video.channelName,
      profileUrl: video.channelUrl,
    },
    metrics: {
      views: video.viewCount,
      likes: video.likes,
      comments: video.commentsCount,
    },
    duration: video.duration,
    publishedAt: video.date ? new Date(video.date) : undefined,
  };
}

/**
 * Download video from any supported platform using Apify
 */
export async function downloadVideoWithApify(
  url: string,
  platform: "tiktok" | "instagram" | "facebook" | "youtube"
): Promise<ApifyVideoResult | null> {
  if (!isApifyConfigured()) {
    throw new Error(
      "Apify is not configured. Please add APIFY_API_TOKEN to your environment variables."
    );
  }

  switch (platform) {
    case "tiktok":
      return downloadTikTokVideo(url);
    case "instagram":
      return downloadInstagramVideo(url);
    case "facebook":
      return downloadFacebookVideo(url);
    case "youtube":
      return downloadYouTubeVideo(url);
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }
}

/**
 * Download the actual video file from the URL returned by Apify
 */
export async function downloadVideoFile(videoUrl: string): Promise<Buffer> {
  console.log("[Apify] Downloading video from URL:", videoUrl);
  
  const response = await fetch(videoUrl, {
    headers: {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      "Referer": "https://www.tiktok.com/",
      "Accept": "*/*",
    },
    redirect: "follow",
  });

  if (!response.ok) {
    throw new Error(`Failed to download video: ${response.status} ${response.statusText}`);
  }

  const contentType = response.headers.get("content-type") || "";
  console.log("[Apify] Download response content-type:", contentType);
  
  // Check if we got HTML instead of video (error page)
  if (contentType.includes("text/html")) {
    const text = await response.text();
    console.log("[Apify] Got HTML instead of video:", text.slice(0, 500));
    throw new Error("Downloaded content is HTML, not a video file. The video URL may have expired or be invalid.");
  }

  const arrayBuffer = await response.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  
  console.log("[Apify] Downloaded", buffer.length, "bytes. First 20 bytes:", buffer.slice(0, 20).toString("hex"));
  
  // Validate it looks like a video file
  if (buffer.length < 1000) {
    throw new Error(`Downloaded file is too small (${buffer.length} bytes). Video URL may be invalid.`);
  }
  
  return buffer;
}

// ============================================================================
// YOUTUBE APIFY SCRAPERS
// ============================================================================

/**
 * Fetch YouTube transcript + metadata using Apify
 * Actor: Uwpce1RSXlrzF6WBA
 * 
 * Input format:
 * {
 *   "include_transcript_text": false,
 *   "youtube_url": "https://www.youtube.com/watch?v=VIDEO_ID"
 * }
 * 
 * Returns: transcript (with timestamps), channel info, views, likes, subscribers
 */
export async function fetchYouTubeTranscript(
  videoUrl: string
): Promise<YouTubeTranscriptResult | null> {
  console.log("[Apify YouTube Transcript] Starting scrape for:", videoUrl);
  
  // Correct input format for this actor
  const results = await runActor(YOUTUBE_ACTORS.transcript, {
    youtube_url: videoUrl,
    include_transcript_text: true, // We want the transcript!
  });

  console.log("[Apify YouTube Transcript] Raw results:", JSON.stringify(results, null, 2).slice(0, 2000));

  if (!results || results.length === 0) {
    console.log("[Apify YouTube Transcript] No results returned");
    return null;
  }

  const video = results[0];
  
  // Check if scrape was successful
  if (video.status !== "success") {
    console.error("[Apify YouTube Transcript] Scrape failed:", video.message);
    return null;
  }

  // Build the full transcript text from segments
  const transcriptSegments = video.transcript || [];
  const fullTranscriptText = transcriptSegments
    .map((seg: { text: string }) => seg.text)
    .join(" ")
    .trim();

  console.log("[Apify YouTube Transcript] Extracted transcript length:", fullTranscriptText.length);
  console.log("[Apify YouTube Transcript] Transcript preview:", fullTranscriptText.slice(0, 500));

  return {
    videoId: video.video_id || video.videoId,
    channelId: video.channel_id || video.channelId,
    channelName: video.channel_name || video.channelName,
    subscriberCount: video.subscriber_count || video.subscriberCount || 0,
    title: video.title,
    description: video.description || "",
    thumbnail: video.thumbnail,
    viewCount: video.view_count || video.viewCount || 0,
    likeCount: video.like_count || video.likeCount || 0,
    commentCount: video.comment_count || video.commentCount || 0,
    durationSeconds: video.duration_seconds || video.durationSeconds || 0,
    publishedAt: video.published_at ? new Date(video.published_at) : new Date(),
    transcript: transcriptSegments.map((seg: { start: number; end: number; text: string }) => ({
      start: seg.start,
      end: seg.end,
      text: seg.text,
    })),
    fullTranscriptText,
    language: video.language || video.selected_language || "en",
    isAutoGenerated: video.is_auto_generated || video.isAutoGenerated || false,
    status: "success",
    message: video.message,
  };
}

/**
 * Fetch video transcript for TikTok, Instagram, Facebook, X
 * Actor: JfsnkyrbdA9JkpkRJ
 * 
 * Uses speech-to-text to transcribe videos from non-YouTube platforms.
 * Much faster than downloading video + Whisper.
 * 
 * Input format:
 * {
 *   "video_url": "https://www.tiktok.com/@user/video/123"
 * }
 */
export async function fetchVideoTranscript(
  videoUrl: string
): Promise<VideoTranscriptResult | null> {
  console.log("[Apify Video Transcript] Starting transcription for:", videoUrl);
  
  const results = await runActor(VIDEO_TRANSCRIPT_ACTOR, {
    video_url: videoUrl,
  }, 120000); // 2 minute timeout

  console.log("[Apify Video Transcript] Raw results:", JSON.stringify(results, null, 2).slice(0, 2000));

  if (!results || results.length === 0) {
    console.log("[Apify Video Transcript] No results returned");
    return null;
  }

  const video = results[0];
  
  // Build the full transcript text from segments
  const transcriptSegments = video.transcript || [];
  const fullTranscriptText = transcriptSegments
    .map((seg: { text: string }) => seg.text)
    .join(" ")
    .trim();

  console.log("[Apify Video Transcript] Extracted transcript length:", fullTranscriptText.length);
  console.log("[Apify Video Transcript] Transcript preview:", fullTranscriptText.slice(0, 500));

  return {
    video_url: video.video_url,
    title: video.title || "",
    description: video.description || "",
    thumbnail: video.thumbnail || "",
    duration: video.duration || 0,
    transcript: transcriptSegments.map((seg: { start: number; end: number; text: string }) => ({
      text: seg.text,
      start: seg.start,
      end: seg.end,
    })),
    fullTranscriptText,
  };
}

/**
 * Get direct YouTube video download URL using Apify
 * Actor: y1IMcEPawMQPafm02
 * 
 * This actor downloads the video and stores it on Apify's key-value store,
 * returning a direct URL that works from any IP (unlike the old actor).
 * 
 * Input format:
 * {
 *   "startUrls": ["https://www.youtube.com/watch?v=VIDEO_ID"],
 *   "quality": "720",
 *   "proxy": { "useApifyProxy": true }
 * }
 * 
 * Output format:
 * [{ "sourceUrl": "...", "downloadUrl": "https://api.apify.com/v2/key-value-stores/..." }]
 * 
 * Returns: Direct video URL hosted on Apify (accessible from any IP)
 */
export async function fetchYouTubeDirectVideoUrl(
  videoUrl: string
): Promise<YouTubeDownloadResult | null> {
  console.log("[Apify YouTube Downloader] Starting download for:", videoUrl);
  
  // New actor input format - must match exactly what works in Apify console
  const results = await runActor(YOUTUBE_ACTORS.downloader, {
    startUrls: [videoUrl],
    quality: "720",
    includeFailedVideos: false,
    useFfmpeg: false,
    proxy: {
      useApifyProxy: true,
      apifyProxyGroups: ["RESIDENTIAL"], // Required for YouTube to work properly
    },
  }, 300000); // 5 minute timeout for video download (actor downloads and stores video)

  console.log("[Apify YouTube Downloader] Raw results:", JSON.stringify(results, null, 2).slice(0, 2000));

  if (!results || results.length === 0) {
    console.log("[Apify YouTube Downloader] No results returned");
    return null;
  }

  const result = results[0];
  
  // New output format: { sourceUrl, downloadUrl }
  if (!result.downloadUrl) {
    console.error("[Apify YouTube Downloader] No downloadUrl in result");
    return null;
  }

  console.log("[Apify YouTube Downloader] Got download URL:", result.downloadUrl);

  // Extract video ID from source URL
  const videoIdMatch = result.sourceUrl?.match(/(?:v=|\/shorts\/|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
  const videoId = videoIdMatch?.[1] || "";

  return {
    videoId,
    title: "", // This actor doesn't return metadata
    channelTitle: "",
    channelId: "",
    description: "",
    thumbnailUrl: "",
    viewCount: 0,
    durationSeconds: 0,
    directVideoUrl: result.downloadUrl,
    formats: [],
  };
}

/**
 * Fetch YouTube comments using Apify
 * Actor: mExYO4A2k9976zMfA
 * 
 * Input format:
 * {
 *   "customMapFunction": "(object) => { return {...object} }",
 *   "maxItems": 1000,
 *   "sort": "top",
 *   "startUrls": ["https://www.youtube.com/watch?v=VIDEO_ID"]
 * }
 * 
 * Returns: Array of comments with author info, text, likes, replies
 */
export async function fetchYouTubeComments(
  videoUrl: string,
  maxComments: number = 100
): Promise<YouTubeCommentsResult | null> {
  console.log("[Apify YouTube Comments] Starting scrape for:", videoUrl);
  
  // Correct input format for this actor - startUrls is array of strings
  const results = await runActor(YOUTUBE_ACTORS.comments, {
    startUrls: [videoUrl], // Array of URL strings, not objects
    maxItems: maxComments,
    sort: "top",
    customMapFunction: "(object) => { return {...object} }",
  }, 180000); // 3 minute timeout for comments

  console.log("[Apify YouTube Comments] Raw results count:", results?.length || 0);
  console.log("[Apify YouTube Comments] First result:", JSON.stringify(results?.[0], null, 2)?.slice(0, 500));

  if (!results || results.length === 0) {
    console.log("[Apify YouTube Comments] No results returned");
    return null;
  }

  // Extract video ID from URL
  const videoIdMatch = videoUrl.match(/(?:youtube\.com\/(?:watch\?v=|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
  const videoId = videoIdMatch?.[1] || "";

  // Parse comments from results
  const comments: YouTubeComment[] = results.map((comment: any) => ({
    id: comment.id,
    text: comment.text,
    likeCount: parseCommentCount(comment.likeCount),
    replyCount: parseCommentCount(comment.replyCount),
    publishedTime: comment.publishedTime,
    author: {
      id: comment["author.id"] || comment.authorId || "",
      name: comment["author.name"] || comment.authorName || "",
    },
  }));

  console.log("[Apify YouTube Comments] Parsed", comments.length, "comments");

  return {
    videoId,
    comments,
    totalComments: comments.length,
  };
}

/**
 * Parse comment count strings like "4K", "5.9K", "2.9K" to numbers
 */
function parseCommentCount(count: string | number | undefined): number {
  if (typeof count === "number") return count;
  if (!count) return 0;
  
  const str = String(count).toLowerCase().trim();
  
  if (str.endsWith("k")) {
    return Math.round(parseFloat(str.replace("k", "")) * 1000);
  }
  if (str.endsWith("m")) {
    return Math.round(parseFloat(str.replace("m", "")) * 1000000);
  }
  
  return parseInt(str, 10) || 0;
}

/**
 * Comprehensive YouTube processing using all three Apify scrapers
 * 
 * Returns combined data from all three scrapers for complete YouTube content processing
 */
export async function processYouTubeWithApify(
  videoUrl: string,
  options: {
    fetchTranscript?: boolean;
    fetchDirectVideoUrl?: boolean;
    fetchComments?: boolean;
    maxComments?: number;
  } = {}
): Promise<{
  transcript?: YouTubeTranscriptResult | null;
  download?: YouTubeDownloadResult | null;
  comments?: YouTubeCommentsResult | null;
}> {
  const {
    fetchTranscript = true,
    fetchDirectVideoUrl = true,
    fetchComments = false,
    maxComments = 100,
  } = options;

  console.log("[Apify YouTube] Processing YouTube content with options:", options);

  // Run scrapers in parallel for efficiency
  const promises: Promise<any>[] = [];
  const results: {
    transcript?: YouTubeTranscriptResult | null;
    download?: YouTubeDownloadResult | null;
    comments?: YouTubeCommentsResult | null;
  } = {};

  if (fetchTranscript) {
    promises.push(
      fetchYouTubeTranscript(videoUrl)
        .then((r) => { results.transcript = r; })
        .catch((e) => { 
          console.error("[Apify YouTube] Transcript scraper failed:", e.message);
          results.transcript = null;
        })
    );
  }

  if (fetchDirectVideoUrl) {
    promises.push(
      fetchYouTubeDirectVideoUrl(videoUrl)
        .then((r) => { results.download = r; })
        .catch((e) => { 
          console.error("[Apify YouTube] Downloader scraper failed:", e.message);
          results.download = null;
        })
    );
  }

  if (fetchComments) {
    promises.push(
      fetchYouTubeComments(videoUrl, maxComments)
        .then((r) => { results.comments = r; })
        .catch((e) => { 
          console.error("[Apify YouTube] Comments scraper failed:", e.message);
          results.comments = null;
        })
    );
  }

  await Promise.all(promises);

  console.log("[Apify YouTube] Processing complete:", {
    hasTranscript: !!results.transcript?.fullTranscriptText,
    hasDirectUrl: !!results.download?.directVideoUrl,
    commentCount: results.comments?.totalComments || 0,
  });

  return results;
}

