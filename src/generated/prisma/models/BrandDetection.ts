
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `BrandDetection` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model BrandDetection
 * 
 */
export type BrandDetectionModel = runtime.Types.Result.DefaultSelection<Prisma.$BrandDetectionPayload>

export type AggregateBrandDetection = {
  _count: BrandDetectionCountAggregateOutputType | null
  _avg: BrandDetectionAvgAggregateOutputType | null
  _sum: BrandDetectionSumAggregateOutputType | null
  _min: BrandDetectionMinAggregateOutputType | null
  _max: BrandDetectionMaxAggregateOutputType | null
}

export type BrandDetectionAvgAggregateOutputType = {
  confidence: number | null
}

export type BrandDetectionSumAggregateOutputType = {
  confidence: number | null
}

export type BrandDetectionMinAggregateOutputType = {
  id: string | null
  contentItemId: string | null
  brandDictionaryId: string | null
  detectionMethod: string | null
  confidence: number | null
  matchedText: string | null
  createdAt: Date | null
}

export type BrandDetectionMaxAggregateOutputType = {
  id: string | null
  contentItemId: string | null
  brandDictionaryId: string | null
  detectionMethod: string | null
  confidence: number | null
  matchedText: string | null
  createdAt: Date | null
}

export type BrandDetectionCountAggregateOutputType = {
  id: number
  contentItemId: number
  brandDictionaryId: number
  detectionMethod: number
  confidence: number
  matchedText: number
  matchedKeywords: number
  createdAt: number
  _all: number
}


export type BrandDetectionAvgAggregateInputType = {
  confidence?: true
}

export type BrandDetectionSumAggregateInputType = {
  confidence?: true
}

export type BrandDetectionMinAggregateInputType = {
  id?: true
  contentItemId?: true
  brandDictionaryId?: true
  detectionMethod?: true
  confidence?: true
  matchedText?: true
  createdAt?: true
}

export type BrandDetectionMaxAggregateInputType = {
  id?: true
  contentItemId?: true
  brandDictionaryId?: true
  detectionMethod?: true
  confidence?: true
  matchedText?: true
  createdAt?: true
}

export type BrandDetectionCountAggregateInputType = {
  id?: true
  contentItemId?: true
  brandDictionaryId?: true
  detectionMethod?: true
  confidence?: true
  matchedText?: true
  matchedKeywords?: true
  createdAt?: true
  _all?: true
}

export type BrandDetectionAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which BrandDetection to aggregate.
   */
  where?: Prisma.BrandDetectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BrandDetections to fetch.
   */
  orderBy?: Prisma.BrandDetectionOrderByWithRelationInput | Prisma.BrandDetectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.BrandDetectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BrandDetections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BrandDetections.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned BrandDetections
  **/
  _count?: true | BrandDetectionCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: BrandDetectionAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: BrandDetectionSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: BrandDetectionMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: BrandDetectionMaxAggregateInputType
}

export type GetBrandDetectionAggregateType<T extends BrandDetectionAggregateArgs> = {
      [P in keyof T & keyof AggregateBrandDetection]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateBrandDetection[P]>
    : Prisma.GetScalarType<T[P], AggregateBrandDetection[P]>
}




export type BrandDetectionGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.BrandDetectionWhereInput
  orderBy?: Prisma.BrandDetectionOrderByWithAggregationInput | Prisma.BrandDetectionOrderByWithAggregationInput[]
  by: Prisma.BrandDetectionScalarFieldEnum[] | Prisma.BrandDetectionScalarFieldEnum
  having?: Prisma.BrandDetectionScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: BrandDetectionCountAggregateInputType | true
  _avg?: BrandDetectionAvgAggregateInputType
  _sum?: BrandDetectionSumAggregateInputType
  _min?: BrandDetectionMinAggregateInputType
  _max?: BrandDetectionMaxAggregateInputType
}

export type BrandDetectionGroupByOutputType = {
  id: string
  contentItemId: string
  brandDictionaryId: string
  detectionMethod: string
  confidence: number
  matchedText: string | null
  matchedKeywords: string[]
  createdAt: Date
  _count: BrandDetectionCountAggregateOutputType | null
  _avg: BrandDetectionAvgAggregateOutputType | null
  _sum: BrandDetectionSumAggregateOutputType | null
  _min: BrandDetectionMinAggregateOutputType | null
  _max: BrandDetectionMaxAggregateOutputType | null
}

type GetBrandDetectionGroupByPayload<T extends BrandDetectionGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<BrandDetectionGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof BrandDetectionGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], BrandDetectionGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], BrandDetectionGroupByOutputType[P]>
      }
    >
  >



export type BrandDetectionWhereInput = {
  AND?: Prisma.BrandDetectionWhereInput | Prisma.BrandDetectionWhereInput[]
  OR?: Prisma.BrandDetectionWhereInput[]
  NOT?: Prisma.BrandDetectionWhereInput | Prisma.BrandDetectionWhereInput[]
  id?: Prisma.StringFilter<"BrandDetection"> | string
  contentItemId?: Prisma.StringFilter<"BrandDetection"> | string
  brandDictionaryId?: Prisma.StringFilter<"BrandDetection"> | string
  detectionMethod?: Prisma.StringFilter<"BrandDetection"> | string
  confidence?: Prisma.FloatFilter<"BrandDetection"> | number
  matchedText?: Prisma.StringNullableFilter<"BrandDetection"> | string | null
  matchedKeywords?: Prisma.StringNullableListFilter<"BrandDetection">
  createdAt?: Prisma.DateTimeFilter<"BrandDetection"> | Date | string
  brandDictionary?: Prisma.XOR<Prisma.BrandDictionaryScalarRelationFilter, Prisma.BrandDictionaryWhereInput>
  contentItem?: Prisma.XOR<Prisma.ContentItemScalarRelationFilter, Prisma.ContentItemWhereInput>
}

export type BrandDetectionOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  contentItemId?: Prisma.SortOrder
  brandDictionaryId?: Prisma.SortOrder
  detectionMethod?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  matchedText?: Prisma.SortOrderInput | Prisma.SortOrder
  matchedKeywords?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  brandDictionary?: Prisma.BrandDictionaryOrderByWithRelationInput
  contentItem?: Prisma.ContentItemOrderByWithRelationInput
}

export type BrandDetectionWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.BrandDetectionWhereInput | Prisma.BrandDetectionWhereInput[]
  OR?: Prisma.BrandDetectionWhereInput[]
  NOT?: Prisma.BrandDetectionWhereInput | Prisma.BrandDetectionWhereInput[]
  contentItemId?: Prisma.StringFilter<"BrandDetection"> | string
  brandDictionaryId?: Prisma.StringFilter<"BrandDetection"> | string
  detectionMethod?: Prisma.StringFilter<"BrandDetection"> | string
  confidence?: Prisma.FloatFilter<"BrandDetection"> | number
  matchedText?: Prisma.StringNullableFilter<"BrandDetection"> | string | null
  matchedKeywords?: Prisma.StringNullableListFilter<"BrandDetection">
  createdAt?: Prisma.DateTimeFilter<"BrandDetection"> | Date | string
  brandDictionary?: Prisma.XOR<Prisma.BrandDictionaryScalarRelationFilter, Prisma.BrandDictionaryWhereInput>
  contentItem?: Prisma.XOR<Prisma.ContentItemScalarRelationFilter, Prisma.ContentItemWhereInput>
}, "id">

export type BrandDetectionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  contentItemId?: Prisma.SortOrder
  brandDictionaryId?: Prisma.SortOrder
  detectionMethod?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  matchedText?: Prisma.SortOrderInput | Prisma.SortOrder
  matchedKeywords?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.BrandDetectionCountOrderByAggregateInput
  _avg?: Prisma.BrandDetectionAvgOrderByAggregateInput
  _max?: Prisma.BrandDetectionMaxOrderByAggregateInput
  _min?: Prisma.BrandDetectionMinOrderByAggregateInput
  _sum?: Prisma.BrandDetectionSumOrderByAggregateInput
}

export type BrandDetectionScalarWhereWithAggregatesInput = {
  AND?: Prisma.BrandDetectionScalarWhereWithAggregatesInput | Prisma.BrandDetectionScalarWhereWithAggregatesInput[]
  OR?: Prisma.BrandDetectionScalarWhereWithAggregatesInput[]
  NOT?: Prisma.BrandDetectionScalarWhereWithAggregatesInput | Prisma.BrandDetectionScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"BrandDetection"> | string
  contentItemId?: Prisma.StringWithAggregatesFilter<"BrandDetection"> | string
  brandDictionaryId?: Prisma.StringWithAggregatesFilter<"BrandDetection"> | string
  detectionMethod?: Prisma.StringWithAggregatesFilter<"BrandDetection"> | string
  confidence?: Prisma.FloatWithAggregatesFilter<"BrandDetection"> | number
  matchedText?: Prisma.StringNullableWithAggregatesFilter<"BrandDetection"> | string | null
  matchedKeywords?: Prisma.StringNullableListFilter<"BrandDetection">
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"BrandDetection"> | Date | string
}

export type BrandDetectionCreateInput = {
  id?: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
  brandDictionary: Prisma.BrandDictionaryCreateNestedOneWithoutDetectionsInput
  contentItem: Prisma.ContentItemCreateNestedOneWithoutBrandDetectionsInput
}

export type BrandDetectionUncheckedCreateInput = {
  id?: string
  contentItemId: string
  brandDictionaryId: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
}

export type BrandDetectionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  brandDictionary?: Prisma.BrandDictionaryUpdateOneRequiredWithoutDetectionsNestedInput
  contentItem?: Prisma.ContentItemUpdateOneRequiredWithoutBrandDetectionsNestedInput
}

export type BrandDetectionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  contentItemId?: Prisma.StringFieldUpdateOperationsInput | string
  brandDictionaryId?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BrandDetectionCreateManyInput = {
  id?: string
  contentItemId: string
  brandDictionaryId: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
}

export type BrandDetectionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BrandDetectionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  contentItemId?: Prisma.StringFieldUpdateOperationsInput | string
  brandDictionaryId?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BrandDetectionListRelationFilter = {
  every?: Prisma.BrandDetectionWhereInput
  some?: Prisma.BrandDetectionWhereInput
  none?: Prisma.BrandDetectionWhereInput
}

export type BrandDetectionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type BrandDetectionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  contentItemId?: Prisma.SortOrder
  brandDictionaryId?: Prisma.SortOrder
  detectionMethod?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  matchedText?: Prisma.SortOrder
  matchedKeywords?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type BrandDetectionAvgOrderByAggregateInput = {
  confidence?: Prisma.SortOrder
}

export type BrandDetectionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  contentItemId?: Prisma.SortOrder
  brandDictionaryId?: Prisma.SortOrder
  detectionMethod?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  matchedText?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type BrandDetectionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  contentItemId?: Prisma.SortOrder
  brandDictionaryId?: Prisma.SortOrder
  detectionMethod?: Prisma.SortOrder
  confidence?: Prisma.SortOrder
  matchedText?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type BrandDetectionSumOrderByAggregateInput = {
  confidence?: Prisma.SortOrder
}

export type BrandDetectionCreateNestedManyWithoutContentItemInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutContentItemInput, Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput> | Prisma.BrandDetectionCreateWithoutContentItemInput[] | Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput | Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput[]
  createMany?: Prisma.BrandDetectionCreateManyContentItemInputEnvelope
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
}

export type BrandDetectionUncheckedCreateNestedManyWithoutContentItemInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutContentItemInput, Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput> | Prisma.BrandDetectionCreateWithoutContentItemInput[] | Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput | Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput[]
  createMany?: Prisma.BrandDetectionCreateManyContentItemInputEnvelope
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
}

export type BrandDetectionUpdateManyWithoutContentItemNestedInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutContentItemInput, Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput> | Prisma.BrandDetectionCreateWithoutContentItemInput[] | Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput | Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput[]
  upsert?: Prisma.BrandDetectionUpsertWithWhereUniqueWithoutContentItemInput | Prisma.BrandDetectionUpsertWithWhereUniqueWithoutContentItemInput[]
  createMany?: Prisma.BrandDetectionCreateManyContentItemInputEnvelope
  set?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  disconnect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  delete?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  update?: Prisma.BrandDetectionUpdateWithWhereUniqueWithoutContentItemInput | Prisma.BrandDetectionUpdateWithWhereUniqueWithoutContentItemInput[]
  updateMany?: Prisma.BrandDetectionUpdateManyWithWhereWithoutContentItemInput | Prisma.BrandDetectionUpdateManyWithWhereWithoutContentItemInput[]
  deleteMany?: Prisma.BrandDetectionScalarWhereInput | Prisma.BrandDetectionScalarWhereInput[]
}

export type BrandDetectionUncheckedUpdateManyWithoutContentItemNestedInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutContentItemInput, Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput> | Prisma.BrandDetectionCreateWithoutContentItemInput[] | Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput | Prisma.BrandDetectionCreateOrConnectWithoutContentItemInput[]
  upsert?: Prisma.BrandDetectionUpsertWithWhereUniqueWithoutContentItemInput | Prisma.BrandDetectionUpsertWithWhereUniqueWithoutContentItemInput[]
  createMany?: Prisma.BrandDetectionCreateManyContentItemInputEnvelope
  set?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  disconnect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  delete?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  update?: Prisma.BrandDetectionUpdateWithWhereUniqueWithoutContentItemInput | Prisma.BrandDetectionUpdateWithWhereUniqueWithoutContentItemInput[]
  updateMany?: Prisma.BrandDetectionUpdateManyWithWhereWithoutContentItemInput | Prisma.BrandDetectionUpdateManyWithWhereWithoutContentItemInput[]
  deleteMany?: Prisma.BrandDetectionScalarWhereInput | Prisma.BrandDetectionScalarWhereInput[]
}

export type BrandDetectionCreateNestedManyWithoutBrandDictionaryInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput> | Prisma.BrandDetectionCreateWithoutBrandDictionaryInput[] | Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput | Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput[]
  createMany?: Prisma.BrandDetectionCreateManyBrandDictionaryInputEnvelope
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
}

export type BrandDetectionUncheckedCreateNestedManyWithoutBrandDictionaryInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput> | Prisma.BrandDetectionCreateWithoutBrandDictionaryInput[] | Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput | Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput[]
  createMany?: Prisma.BrandDetectionCreateManyBrandDictionaryInputEnvelope
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
}

export type BrandDetectionUpdateManyWithoutBrandDictionaryNestedInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput> | Prisma.BrandDetectionCreateWithoutBrandDictionaryInput[] | Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput | Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput[]
  upsert?: Prisma.BrandDetectionUpsertWithWhereUniqueWithoutBrandDictionaryInput | Prisma.BrandDetectionUpsertWithWhereUniqueWithoutBrandDictionaryInput[]
  createMany?: Prisma.BrandDetectionCreateManyBrandDictionaryInputEnvelope
  set?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  disconnect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  delete?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  update?: Prisma.BrandDetectionUpdateWithWhereUniqueWithoutBrandDictionaryInput | Prisma.BrandDetectionUpdateWithWhereUniqueWithoutBrandDictionaryInput[]
  updateMany?: Prisma.BrandDetectionUpdateManyWithWhereWithoutBrandDictionaryInput | Prisma.BrandDetectionUpdateManyWithWhereWithoutBrandDictionaryInput[]
  deleteMany?: Prisma.BrandDetectionScalarWhereInput | Prisma.BrandDetectionScalarWhereInput[]
}

export type BrandDetectionUncheckedUpdateManyWithoutBrandDictionaryNestedInput = {
  create?: Prisma.XOR<Prisma.BrandDetectionCreateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput> | Prisma.BrandDetectionCreateWithoutBrandDictionaryInput[] | Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput[]
  connectOrCreate?: Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput | Prisma.BrandDetectionCreateOrConnectWithoutBrandDictionaryInput[]
  upsert?: Prisma.BrandDetectionUpsertWithWhereUniqueWithoutBrandDictionaryInput | Prisma.BrandDetectionUpsertWithWhereUniqueWithoutBrandDictionaryInput[]
  createMany?: Prisma.BrandDetectionCreateManyBrandDictionaryInputEnvelope
  set?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  disconnect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  delete?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  connect?: Prisma.BrandDetectionWhereUniqueInput | Prisma.BrandDetectionWhereUniqueInput[]
  update?: Prisma.BrandDetectionUpdateWithWhereUniqueWithoutBrandDictionaryInput | Prisma.BrandDetectionUpdateWithWhereUniqueWithoutBrandDictionaryInput[]
  updateMany?: Prisma.BrandDetectionUpdateManyWithWhereWithoutBrandDictionaryInput | Prisma.BrandDetectionUpdateManyWithWhereWithoutBrandDictionaryInput[]
  deleteMany?: Prisma.BrandDetectionScalarWhereInput | Prisma.BrandDetectionScalarWhereInput[]
}

export type BrandDetectionCreatematchedKeywordsInput = {
  set: string[]
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type BrandDetectionUpdatematchedKeywordsInput = {
  set?: string[]
  push?: string | string[]
}

export type BrandDetectionCreateWithoutContentItemInput = {
  id?: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
  brandDictionary: Prisma.BrandDictionaryCreateNestedOneWithoutDetectionsInput
}

export type BrandDetectionUncheckedCreateWithoutContentItemInput = {
  id?: string
  brandDictionaryId: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
}

export type BrandDetectionCreateOrConnectWithoutContentItemInput = {
  where: Prisma.BrandDetectionWhereUniqueInput
  create: Prisma.XOR<Prisma.BrandDetectionCreateWithoutContentItemInput, Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput>
}

export type BrandDetectionCreateManyContentItemInputEnvelope = {
  data: Prisma.BrandDetectionCreateManyContentItemInput | Prisma.BrandDetectionCreateManyContentItemInput[]
  skipDuplicates?: boolean
}

export type BrandDetectionUpsertWithWhereUniqueWithoutContentItemInput = {
  where: Prisma.BrandDetectionWhereUniqueInput
  update: Prisma.XOR<Prisma.BrandDetectionUpdateWithoutContentItemInput, Prisma.BrandDetectionUncheckedUpdateWithoutContentItemInput>
  create: Prisma.XOR<Prisma.BrandDetectionCreateWithoutContentItemInput, Prisma.BrandDetectionUncheckedCreateWithoutContentItemInput>
}

export type BrandDetectionUpdateWithWhereUniqueWithoutContentItemInput = {
  where: Prisma.BrandDetectionWhereUniqueInput
  data: Prisma.XOR<Prisma.BrandDetectionUpdateWithoutContentItemInput, Prisma.BrandDetectionUncheckedUpdateWithoutContentItemInput>
}

export type BrandDetectionUpdateManyWithWhereWithoutContentItemInput = {
  where: Prisma.BrandDetectionScalarWhereInput
  data: Prisma.XOR<Prisma.BrandDetectionUpdateManyMutationInput, Prisma.BrandDetectionUncheckedUpdateManyWithoutContentItemInput>
}

export type BrandDetectionScalarWhereInput = {
  AND?: Prisma.BrandDetectionScalarWhereInput | Prisma.BrandDetectionScalarWhereInput[]
  OR?: Prisma.BrandDetectionScalarWhereInput[]
  NOT?: Prisma.BrandDetectionScalarWhereInput | Prisma.BrandDetectionScalarWhereInput[]
  id?: Prisma.StringFilter<"BrandDetection"> | string
  contentItemId?: Prisma.StringFilter<"BrandDetection"> | string
  brandDictionaryId?: Prisma.StringFilter<"BrandDetection"> | string
  detectionMethod?: Prisma.StringFilter<"BrandDetection"> | string
  confidence?: Prisma.FloatFilter<"BrandDetection"> | number
  matchedText?: Prisma.StringNullableFilter<"BrandDetection"> | string | null
  matchedKeywords?: Prisma.StringNullableListFilter<"BrandDetection">
  createdAt?: Prisma.DateTimeFilter<"BrandDetection"> | Date | string
}

export type BrandDetectionCreateWithoutBrandDictionaryInput = {
  id?: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
  contentItem: Prisma.ContentItemCreateNestedOneWithoutBrandDetectionsInput
}

export type BrandDetectionUncheckedCreateWithoutBrandDictionaryInput = {
  id?: string
  contentItemId: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
}

export type BrandDetectionCreateOrConnectWithoutBrandDictionaryInput = {
  where: Prisma.BrandDetectionWhereUniqueInput
  create: Prisma.XOR<Prisma.BrandDetectionCreateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput>
}

export type BrandDetectionCreateManyBrandDictionaryInputEnvelope = {
  data: Prisma.BrandDetectionCreateManyBrandDictionaryInput | Prisma.BrandDetectionCreateManyBrandDictionaryInput[]
  skipDuplicates?: boolean
}

export type BrandDetectionUpsertWithWhereUniqueWithoutBrandDictionaryInput = {
  where: Prisma.BrandDetectionWhereUniqueInput
  update: Prisma.XOR<Prisma.BrandDetectionUpdateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedUpdateWithoutBrandDictionaryInput>
  create: Prisma.XOR<Prisma.BrandDetectionCreateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedCreateWithoutBrandDictionaryInput>
}

export type BrandDetectionUpdateWithWhereUniqueWithoutBrandDictionaryInput = {
  where: Prisma.BrandDetectionWhereUniqueInput
  data: Prisma.XOR<Prisma.BrandDetectionUpdateWithoutBrandDictionaryInput, Prisma.BrandDetectionUncheckedUpdateWithoutBrandDictionaryInput>
}

export type BrandDetectionUpdateManyWithWhereWithoutBrandDictionaryInput = {
  where: Prisma.BrandDetectionScalarWhereInput
  data: Prisma.XOR<Prisma.BrandDetectionUpdateManyMutationInput, Prisma.BrandDetectionUncheckedUpdateManyWithoutBrandDictionaryInput>
}

export type BrandDetectionCreateManyContentItemInput = {
  id?: string
  brandDictionaryId: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
}

export type BrandDetectionUpdateWithoutContentItemInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  brandDictionary?: Prisma.BrandDictionaryUpdateOneRequiredWithoutDetectionsNestedInput
}

export type BrandDetectionUncheckedUpdateWithoutContentItemInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  brandDictionaryId?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BrandDetectionUncheckedUpdateManyWithoutContentItemInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  brandDictionaryId?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BrandDetectionCreateManyBrandDictionaryInput = {
  id?: string
  contentItemId: string
  detectionMethod: string
  confidence: number
  matchedText?: string | null
  matchedKeywords?: Prisma.BrandDetectionCreatematchedKeywordsInput | string[]
  createdAt?: Date | string
}

export type BrandDetectionUpdateWithoutBrandDictionaryInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  contentItem?: Prisma.ContentItemUpdateOneRequiredWithoutBrandDetectionsNestedInput
}

export type BrandDetectionUncheckedUpdateWithoutBrandDictionaryInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  contentItemId?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type BrandDetectionUncheckedUpdateManyWithoutBrandDictionaryInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  contentItemId?: Prisma.StringFieldUpdateOperationsInput | string
  detectionMethod?: Prisma.StringFieldUpdateOperationsInput | string
  confidence?: Prisma.FloatFieldUpdateOperationsInput | number
  matchedText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  matchedKeywords?: Prisma.BrandDetectionUpdatematchedKeywordsInput | string[]
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type BrandDetectionSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  contentItemId?: boolean
  brandDictionaryId?: boolean
  detectionMethod?: boolean
  confidence?: boolean
  matchedText?: boolean
  matchedKeywords?: boolean
  createdAt?: boolean
  brandDictionary?: boolean | Prisma.BrandDictionaryDefaultArgs<ExtArgs>
  contentItem?: boolean | Prisma.ContentItemDefaultArgs<ExtArgs>
}, ExtArgs["result"]["brandDetection"]>

export type BrandDetectionSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  contentItemId?: boolean
  brandDictionaryId?: boolean
  detectionMethod?: boolean
  confidence?: boolean
  matchedText?: boolean
  matchedKeywords?: boolean
  createdAt?: boolean
  brandDictionary?: boolean | Prisma.BrandDictionaryDefaultArgs<ExtArgs>
  contentItem?: boolean | Prisma.ContentItemDefaultArgs<ExtArgs>
}, ExtArgs["result"]["brandDetection"]>

export type BrandDetectionSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  contentItemId?: boolean
  brandDictionaryId?: boolean
  detectionMethod?: boolean
  confidence?: boolean
  matchedText?: boolean
  matchedKeywords?: boolean
  createdAt?: boolean
  brandDictionary?: boolean | Prisma.BrandDictionaryDefaultArgs<ExtArgs>
  contentItem?: boolean | Prisma.ContentItemDefaultArgs<ExtArgs>
}, ExtArgs["result"]["brandDetection"]>

export type BrandDetectionSelectScalar = {
  id?: boolean
  contentItemId?: boolean
  brandDictionaryId?: boolean
  detectionMethod?: boolean
  confidence?: boolean
  matchedText?: boolean
  matchedKeywords?: boolean
  createdAt?: boolean
}

export type BrandDetectionOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "contentItemId" | "brandDictionaryId" | "detectionMethod" | "confidence" | "matchedText" | "matchedKeywords" | "createdAt", ExtArgs["result"]["brandDetection"]>
export type BrandDetectionInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  brandDictionary?: boolean | Prisma.BrandDictionaryDefaultArgs<ExtArgs>
  contentItem?: boolean | Prisma.ContentItemDefaultArgs<ExtArgs>
}
export type BrandDetectionIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  brandDictionary?: boolean | Prisma.BrandDictionaryDefaultArgs<ExtArgs>
  contentItem?: boolean | Prisma.ContentItemDefaultArgs<ExtArgs>
}
export type BrandDetectionIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  brandDictionary?: boolean | Prisma.BrandDictionaryDefaultArgs<ExtArgs>
  contentItem?: boolean | Prisma.ContentItemDefaultArgs<ExtArgs>
}

export type $BrandDetectionPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "BrandDetection"
  objects: {
    brandDictionary: Prisma.$BrandDictionaryPayload<ExtArgs>
    contentItem: Prisma.$ContentItemPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    contentItemId: string
    brandDictionaryId: string
    detectionMethod: string
    confidence: number
    matchedText: string | null
    matchedKeywords: string[]
    createdAt: Date
  }, ExtArgs["result"]["brandDetection"]>
  composites: {}
}

export type BrandDetectionGetPayload<S extends boolean | null | undefined | BrandDetectionDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload, S>

export type BrandDetectionCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<BrandDetectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: BrandDetectionCountAggregateInputType | true
  }

export interface BrandDetectionDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BrandDetection'], meta: { name: 'BrandDetection' } }
  /**
   * Find zero or one BrandDetection that matches the filter.
   * @param {BrandDetectionFindUniqueArgs} args - Arguments to find a BrandDetection
   * @example
   * // Get one BrandDetection
   * const brandDetection = await prisma.brandDetection.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends BrandDetectionFindUniqueArgs>(args: Prisma.SelectSubset<T, BrandDetectionFindUniqueArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one BrandDetection that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {BrandDetectionFindUniqueOrThrowArgs} args - Arguments to find a BrandDetection
   * @example
   * // Get one BrandDetection
   * const brandDetection = await prisma.brandDetection.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends BrandDetectionFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, BrandDetectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first BrandDetection that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BrandDetectionFindFirstArgs} args - Arguments to find a BrandDetection
   * @example
   * // Get one BrandDetection
   * const brandDetection = await prisma.brandDetection.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends BrandDetectionFindFirstArgs>(args?: Prisma.SelectSubset<T, BrandDetectionFindFirstArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first BrandDetection that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BrandDetectionFindFirstOrThrowArgs} args - Arguments to find a BrandDetection
   * @example
   * // Get one BrandDetection
   * const brandDetection = await prisma.brandDetection.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends BrandDetectionFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, BrandDetectionFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more BrandDetections that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BrandDetectionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all BrandDetections
   * const brandDetections = await prisma.brandDetection.findMany()
   * 
   * // Get first 10 BrandDetections
   * const brandDetections = await prisma.brandDetection.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const brandDetectionWithIdOnly = await prisma.brandDetection.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends BrandDetectionFindManyArgs>(args?: Prisma.SelectSubset<T, BrandDetectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a BrandDetection.
   * @param {BrandDetectionCreateArgs} args - Arguments to create a BrandDetection.
   * @example
   * // Create one BrandDetection
   * const BrandDetection = await prisma.brandDetection.create({
   *   data: {
   *     // ... data to create a BrandDetection
   *   }
   * })
   * 
   */
  create<T extends BrandDetectionCreateArgs>(args: Prisma.SelectSubset<T, BrandDetectionCreateArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many BrandDetections.
   * @param {BrandDetectionCreateManyArgs} args - Arguments to create many BrandDetections.
   * @example
   * // Create many BrandDetections
   * const brandDetection = await prisma.brandDetection.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends BrandDetectionCreateManyArgs>(args?: Prisma.SelectSubset<T, BrandDetectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many BrandDetections and returns the data saved in the database.
   * @param {BrandDetectionCreateManyAndReturnArgs} args - Arguments to create many BrandDetections.
   * @example
   * // Create many BrandDetections
   * const brandDetection = await prisma.brandDetection.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many BrandDetections and only return the `id`
   * const brandDetectionWithIdOnly = await prisma.brandDetection.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends BrandDetectionCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, BrandDetectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a BrandDetection.
   * @param {BrandDetectionDeleteArgs} args - Arguments to delete one BrandDetection.
   * @example
   * // Delete one BrandDetection
   * const BrandDetection = await prisma.brandDetection.delete({
   *   where: {
   *     // ... filter to delete one BrandDetection
   *   }
   * })
   * 
   */
  delete<T extends BrandDetectionDeleteArgs>(args: Prisma.SelectSubset<T, BrandDetectionDeleteArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one BrandDetection.
   * @param {BrandDetectionUpdateArgs} args - Arguments to update one BrandDetection.
   * @example
   * // Update one BrandDetection
   * const brandDetection = await prisma.brandDetection.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends BrandDetectionUpdateArgs>(args: Prisma.SelectSubset<T, BrandDetectionUpdateArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more BrandDetections.
   * @param {BrandDetectionDeleteManyArgs} args - Arguments to filter BrandDetections to delete.
   * @example
   * // Delete a few BrandDetections
   * const { count } = await prisma.brandDetection.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends BrandDetectionDeleteManyArgs>(args?: Prisma.SelectSubset<T, BrandDetectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more BrandDetections.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BrandDetectionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many BrandDetections
   * const brandDetection = await prisma.brandDetection.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends BrandDetectionUpdateManyArgs>(args: Prisma.SelectSubset<T, BrandDetectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more BrandDetections and returns the data updated in the database.
   * @param {BrandDetectionUpdateManyAndReturnArgs} args - Arguments to update many BrandDetections.
   * @example
   * // Update many BrandDetections
   * const brandDetection = await prisma.brandDetection.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more BrandDetections and only return the `id`
   * const brandDetectionWithIdOnly = await prisma.brandDetection.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends BrandDetectionUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, BrandDetectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one BrandDetection.
   * @param {BrandDetectionUpsertArgs} args - Arguments to update or create a BrandDetection.
   * @example
   * // Update or create a BrandDetection
   * const brandDetection = await prisma.brandDetection.upsert({
   *   create: {
   *     // ... data to create a BrandDetection
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the BrandDetection we want to update
   *   }
   * })
   */
  upsert<T extends BrandDetectionUpsertArgs>(args: Prisma.SelectSubset<T, BrandDetectionUpsertArgs<ExtArgs>>): Prisma.Prisma__BrandDetectionClient<runtime.Types.Result.GetResult<Prisma.$BrandDetectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of BrandDetections.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BrandDetectionCountArgs} args - Arguments to filter BrandDetections to count.
   * @example
   * // Count the number of BrandDetections
   * const count = await prisma.brandDetection.count({
   *   where: {
   *     // ... the filter for the BrandDetections we want to count
   *   }
   * })
  **/
  count<T extends BrandDetectionCountArgs>(
    args?: Prisma.Subset<T, BrandDetectionCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], BrandDetectionCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a BrandDetection.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BrandDetectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends BrandDetectionAggregateArgs>(args: Prisma.Subset<T, BrandDetectionAggregateArgs>): Prisma.PrismaPromise<GetBrandDetectionAggregateType<T>>

  /**
   * Group by BrandDetection.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {BrandDetectionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends BrandDetectionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: BrandDetectionGroupByArgs['orderBy'] }
      : { orderBy?: BrandDetectionGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, BrandDetectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandDetectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the BrandDetection model
 */
readonly fields: BrandDetectionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for BrandDetection.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__BrandDetectionClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  brandDictionary<T extends Prisma.BrandDictionaryDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.BrandDictionaryDefaultArgs<ExtArgs>>): Prisma.Prisma__BrandDictionaryClient<runtime.Types.Result.GetResult<Prisma.$BrandDictionaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  contentItem<T extends Prisma.ContentItemDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ContentItemDefaultArgs<ExtArgs>>): Prisma.Prisma__ContentItemClient<runtime.Types.Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the BrandDetection model
 */
export interface BrandDetectionFieldRefs {
  readonly id: Prisma.FieldRef<"BrandDetection", 'String'>
  readonly contentItemId: Prisma.FieldRef<"BrandDetection", 'String'>
  readonly brandDictionaryId: Prisma.FieldRef<"BrandDetection", 'String'>
  readonly detectionMethod: Prisma.FieldRef<"BrandDetection", 'String'>
  readonly confidence: Prisma.FieldRef<"BrandDetection", 'Float'>
  readonly matchedText: Prisma.FieldRef<"BrandDetection", 'String'>
  readonly matchedKeywords: Prisma.FieldRef<"BrandDetection", 'String[]'>
  readonly createdAt: Prisma.FieldRef<"BrandDetection", 'DateTime'>
}
    

// Custom InputTypes
/**
 * BrandDetection findUnique
 */
export type BrandDetectionFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * Filter, which BrandDetection to fetch.
   */
  where: Prisma.BrandDetectionWhereUniqueInput
}

/**
 * BrandDetection findUniqueOrThrow
 */
export type BrandDetectionFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * Filter, which BrandDetection to fetch.
   */
  where: Prisma.BrandDetectionWhereUniqueInput
}

/**
 * BrandDetection findFirst
 */
export type BrandDetectionFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * Filter, which BrandDetection to fetch.
   */
  where?: Prisma.BrandDetectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BrandDetections to fetch.
   */
  orderBy?: Prisma.BrandDetectionOrderByWithRelationInput | Prisma.BrandDetectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for BrandDetections.
   */
  cursor?: Prisma.BrandDetectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BrandDetections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BrandDetections.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of BrandDetections.
   */
  distinct?: Prisma.BrandDetectionScalarFieldEnum | Prisma.BrandDetectionScalarFieldEnum[]
}

/**
 * BrandDetection findFirstOrThrow
 */
export type BrandDetectionFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * Filter, which BrandDetection to fetch.
   */
  where?: Prisma.BrandDetectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BrandDetections to fetch.
   */
  orderBy?: Prisma.BrandDetectionOrderByWithRelationInput | Prisma.BrandDetectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for BrandDetections.
   */
  cursor?: Prisma.BrandDetectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BrandDetections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BrandDetections.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of BrandDetections.
   */
  distinct?: Prisma.BrandDetectionScalarFieldEnum | Prisma.BrandDetectionScalarFieldEnum[]
}

/**
 * BrandDetection findMany
 */
export type BrandDetectionFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * Filter, which BrandDetections to fetch.
   */
  where?: Prisma.BrandDetectionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of BrandDetections to fetch.
   */
  orderBy?: Prisma.BrandDetectionOrderByWithRelationInput | Prisma.BrandDetectionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing BrandDetections.
   */
  cursor?: Prisma.BrandDetectionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` BrandDetections from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` BrandDetections.
   */
  skip?: number
  distinct?: Prisma.BrandDetectionScalarFieldEnum | Prisma.BrandDetectionScalarFieldEnum[]
}

/**
 * BrandDetection create
 */
export type BrandDetectionCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * The data needed to create a BrandDetection.
   */
  data: Prisma.XOR<Prisma.BrandDetectionCreateInput, Prisma.BrandDetectionUncheckedCreateInput>
}

/**
 * BrandDetection createMany
 */
export type BrandDetectionCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many BrandDetections.
   */
  data: Prisma.BrandDetectionCreateManyInput | Prisma.BrandDetectionCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * BrandDetection createManyAndReturn
 */
export type BrandDetectionCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * The data used to create many BrandDetections.
   */
  data: Prisma.BrandDetectionCreateManyInput | Prisma.BrandDetectionCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * BrandDetection update
 */
export type BrandDetectionUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * The data needed to update a BrandDetection.
   */
  data: Prisma.XOR<Prisma.BrandDetectionUpdateInput, Prisma.BrandDetectionUncheckedUpdateInput>
  /**
   * Choose, which BrandDetection to update.
   */
  where: Prisma.BrandDetectionWhereUniqueInput
}

/**
 * BrandDetection updateMany
 */
export type BrandDetectionUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update BrandDetections.
   */
  data: Prisma.XOR<Prisma.BrandDetectionUpdateManyMutationInput, Prisma.BrandDetectionUncheckedUpdateManyInput>
  /**
   * Filter which BrandDetections to update
   */
  where?: Prisma.BrandDetectionWhereInput
  /**
   * Limit how many BrandDetections to update.
   */
  limit?: number
}

/**
 * BrandDetection updateManyAndReturn
 */
export type BrandDetectionUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * The data used to update BrandDetections.
   */
  data: Prisma.XOR<Prisma.BrandDetectionUpdateManyMutationInput, Prisma.BrandDetectionUncheckedUpdateManyInput>
  /**
   * Filter which BrandDetections to update
   */
  where?: Prisma.BrandDetectionWhereInput
  /**
   * Limit how many BrandDetections to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * BrandDetection upsert
 */
export type BrandDetectionUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * The filter to search for the BrandDetection to update in case it exists.
   */
  where: Prisma.BrandDetectionWhereUniqueInput
  /**
   * In case the BrandDetection found by the `where` argument doesn't exist, create a new BrandDetection with this data.
   */
  create: Prisma.XOR<Prisma.BrandDetectionCreateInput, Prisma.BrandDetectionUncheckedCreateInput>
  /**
   * In case the BrandDetection was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.BrandDetectionUpdateInput, Prisma.BrandDetectionUncheckedUpdateInput>
}

/**
 * BrandDetection delete
 */
export type BrandDetectionDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
  /**
   * Filter which BrandDetection to delete.
   */
  where: Prisma.BrandDetectionWhereUniqueInput
}

/**
 * BrandDetection deleteMany
 */
export type BrandDetectionDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which BrandDetections to delete
   */
  where?: Prisma.BrandDetectionWhereInput
  /**
   * Limit how many BrandDetections to delete.
   */
  limit?: number
}

/**
 * BrandDetection without action
 */
export type BrandDetectionDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BrandDetection
   */
  select?: Prisma.BrandDetectionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BrandDetection
   */
  omit?: Prisma.BrandDetectionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BrandDetectionInclude<ExtArgs> | null
}
